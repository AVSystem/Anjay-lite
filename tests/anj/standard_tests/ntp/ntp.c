/*
 * Copyright 2023-2026 AVSystem <avsystem@avsystem.com>
 * AVSystem Anjay Lite LwM2M SDK
 * All rights reserved.
 *
 * Licensed under AVSystem Anjay Lite LwM2M Client SDK - Non-Commercial License.
 * See the attached LICENSE file for details.
 */

#include <stdbool.h>
#include <stdint.h>
#include <string.h>

#include <anj/compat/net/anj_net_api.h>
#include <anj/core.h>
#include <anj/defs.h>
#include <anj/dm/core.h>
#include <anj/dm/defs.h>
#include <anj/ntp.h>
#include <anj/time.h>
#include <anj/utils.h>

#include "../mock/net_api_mock.h"
#include "../mock/time_api_mock.h"

#include "../../../../src/anj/dm/dm_io.h"

#include <anj_unit_test.h>

static anj_ntp_status_t g_ntp_status;
static int g_ntp_callback_counter;
static anj_time_real_t g_ntp_synchronized_time;

static void ntp_event_callback(void *arg,
                               anj_ntp_t *ntp,
                               anj_ntp_status_t status,
                               anj_time_real_t synchronized_time) {
    (void) arg;
    (void) ntp;
    g_ntp_status = status;
    g_ntp_callback_counter++;
    g_ntp_synchronized_time = synchronized_time;

    if (status == ANJ_NTP_STATUS_PERIOD_EXCEEDED) {
        // for tests, start synchronization immediately when period is exceeded
        // - this simulates application behavior
        ANJ_UNIT_ASSERT_SUCCESS(anj_ntp_start(ntp));
    }
}

/* Helper: build a minimal valid NTP response.
 * Only the transmit timestamp (bytes 40–43) matters for parse_ntp_response().
 */
static void make_ntp_response(uint8_t *buf, uint32_t unix_seconds) {
    memset(buf, 0, _ANJ_NTP_MSG_SIZE);
    /* LI = 0, Version = 4, Mode = 4 (server) */
    buf[0] = 0x24;

    /* NTP timestamp = Unix + offset 1900–1970 */
    const uint32_t NTP_UNIX_EPOCH_DIFF = 2208988800U;
    uint32_t ntp_seconds = unix_seconds + NTP_UNIX_EPOCH_DIFF;

    buf[40] = (uint8_t) (ntp_seconds >> 24);
    buf[41] = (uint8_t) (ntp_seconds >> 16);
    buf[42] = (uint8_t) (ntp_seconds >> 8);
    buf[43] = (uint8_t) (ntp_seconds);
}

/* Helper: expected NTP request generated by prepare_ntp_request():
 * first byte 0x23, rest zero.
 */
static uint8_t ntp_request_expected[_ANJ_NTP_MSG_SIZE] = { 0x23 };

#define NTP_TEST_INIT()                                                \
    mock_time_reset();                                                 \
    net_api_mock_t mock = { 0 };                                       \
    net_api_mock_ctx_init(&mock);                                      \
    mock.inner_mtu_value = 100;                                        \
    anj_t anj = { 0 };                                                 \
    anj_ntp_t ntp;                                                     \
    char primary_addr[] = "test.ntp.org";                              \
    anj_ntp_configuration_t config = {                                 \
        .event_cb = ntp_event_callback,                                \
        .event_cb_arg = NULL,                                          \
        .ntp_server_address = primary_addr,                            \
        .backup_ntp_server_address = NULL,                             \
        .attempts = 1,                                                 \
        .response_timeout = anj_time_duration_new(5, ANJ_TIME_UNIT_S), \
    };                                                                 \
    g_ntp_status = ANJ_NTP_STATUS_INITIAL;                             \
    g_ntp_callback_counter = 0;                                        \
    g_ntp_synchronized_time = ANJ_TIME_REAL_ZERO

#define SET_NET_MOCK_API()                               \
    mock.bytes_to_send = 100;                            \
    uint8_t ntp_response[_ANJ_NTP_MSG_SIZE];             \
    uint32_t expected_unix_time = 0x57645747;            \
    make_ntp_response(ntp_response, expected_unix_time); \
    mock.data_to_recv = ntp_response;                    \
    mock.bytes_to_recv = sizeof(ntp_response)

/* 1. Basic happy-path synchronization:
 *    - start NTP
 *    - send request
 *    - receive valid response
 *    - finish with ANJ_NTP_STATUS_FINISHED_SUCCESSFULLY
 */
ANJ_UNIT_TEST(ntp, basic_synchronization) {
    NTP_TEST_INIT();
    ANJ_UNIT_ASSERT_SUCCESS(anj_ntp_init(&anj, &ntp, &config));
    anj_ntp_step(&ntp);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_status, ANJ_NTP_STATUS_INITIAL);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_callback_counter, 1);

    ANJ_UNIT_ASSERT_SUCCESS(anj_ntp_start(&ntp));
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_status, ANJ_NTP_STATUS_IN_PROGRESS);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_callback_counter, 2);

    /* Step 1: connect and send NTP request */
    // connect
    anj_ntp_step(&ntp);
    // send request with EAGAIN here to simulate non-blocking socket
    anj_ntp_step(&ntp);
    mock.bytes_to_send = 100;
    // send request
    anj_ntp_step(&ntp);
    ANJ_UNIT_ASSERT_EQUAL(mock.bytes_sent, _ANJ_NTP_MSG_SIZE);
    ANJ_UNIT_ASSERT_EQUAL_BYTES_SIZED(
            mock.send_data_buffer, ntp_request_expected, _ANJ_NTP_MSG_SIZE);

    /* Step 2: receive NTP response */
    // receive response with EAGAIN here to simulate non-blocking socket
    anj_ntp_step(&ntp);
    anj_ntp_step(&ntp);
    uint8_t ntp_response[_ANJ_NTP_MSG_SIZE];
    uint32_t expected_unix_time = 0x57645747; // random timestamp
    make_ntp_response(ntp_response, expected_unix_time);
    mock.bytes_to_recv = sizeof(ntp_response);
    mock.data_to_recv = ntp_response;
    anj_ntp_step(&ntp);

    ANJ_UNIT_ASSERT_EQUAL(g_ntp_status, ANJ_NTP_STATUS_FINISHED_SUCCESSFULLY);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_callback_counter, 3);
    ANJ_UNIT_ASSERT_EQUAL(anj_time_real_to_scalar(g_ntp_synchronized_time,
                                                  ANJ_TIME_UNIT_S),
                          expected_unix_time);
    // check if fractional part is parsed correctly - should be zero here
    ANJ_UNIT_ASSERT_EQUAL(anj_time_real_to_scalar(g_ntp_synchronized_time,
                                                  ANJ_TIME_UNIT_MS),
                          (int64_t) expected_unix_time * 1000);
}

ANJ_UNIT_TEST(ntp, invalid_configurations) {
    // valid configuration
    {
        anj_t anj = { 0 };
        anj_ntp_t ntp;
        anj_ntp_configuration_t config = {
            .event_cb = ntp_event_callback,
            .ntp_server_address = "test.ntp.org",
            .backup_ntp_server_address = "test2.ntp.org",
        };
        ANJ_UNIT_ASSERT_EQUAL(anj_ntp_init(&anj, &ntp, &config), 0);
    }
    // missing event callback
    {
        anj_t anj = { 0 };
        anj_ntp_t ntp;
        anj_ntp_configuration_t config = {
            .event_cb = NULL,
            .ntp_server_address = "test.ntp.org",
        };
        ANJ_UNIT_ASSERT_EQUAL(anj_ntp_init(&anj, &ntp, &config),
                              ANJ_NTP_ERR_CONFIGURATION);
    }
    // missing NTP server address
    {
        anj_t anj = { 0 };
        anj_ntp_t ntp;
        anj_ntp_configuration_t config = {
            .event_cb = ntp_event_callback,
            .ntp_server_address = NULL,
        };
        ANJ_UNIT_ASSERT_EQUAL(anj_ntp_init(&anj, &ntp, &config),
                              ANJ_NTP_ERR_CONFIGURATION);
    }
    // empty NTP server address
    {
        anj_t anj = { 0 };
        anj_ntp_t ntp;
        anj_ntp_configuration_t config = {
            .event_cb = ntp_event_callback,
            .ntp_server_address = "",
        };
        ANJ_UNIT_ASSERT_EQUAL(anj_ntp_init(&anj, &ntp, &config),
                              ANJ_NTP_ERR_CONFIGURATION);
    }
    // too long NTP server address
    {
        anj_t anj = { 0 };
        anj_ntp_t ntp;
        anj_ntp_configuration_t config = {
            .event_cb = ntp_event_callback,
            .ntp_server_address = "abcdefghijklmnopqrstuvwxyzabcde",
        };
        ANJ_UNIT_ASSERT_EQUAL(anj_ntp_init(&anj, &ntp, &config),
                              ANJ_NTP_ERR_CONFIGURATION);
    }
    // too long backup NTP server address
    {
        anj_t anj = { 0 };
        anj_ntp_t ntp;
        anj_ntp_configuration_t config = {
            .event_cb = ntp_event_callback,
            .ntp_server_address = "test.ntp.org",
            .backup_ntp_server_address = "abcdefghijklmnopqrstuvwxyzabcde",
        };
        ANJ_UNIT_ASSERT_EQUAL(anj_ntp_init(&anj, &ntp, &config),
                              ANJ_NTP_ERR_CONFIGURATION);
    }
}

// check if two consecutive synchronizations work correctly
ANJ_UNIT_TEST(ntp, two_synchronizations) {
    NTP_TEST_INIT();
    ANJ_UNIT_ASSERT_SUCCESS(anj_ntp_init(&anj, &ntp, &config));

    // First synchronization
    ANJ_UNIT_ASSERT_SUCCESS(anj_ntp_start(&ntp));
    SET_NET_MOCK_API();
    // connect
    anj_ntp_step(&ntp);
    // send request
    anj_ntp_step(&ntp);
    // receive response
    anj_ntp_step(&ntp);
    // disconnect
    anj_ntp_step(&ntp);
    // first status is IN_PROGRESS and then FINISHED_SUCCESSFULLY
    // we didn't call anj_ntp_step() before anj_ntp_start(), so there is no
    // ANJ_NTP_STATUS_INITIAL callback
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_callback_counter, 2);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_status, ANJ_NTP_STATUS_FINISHED_SUCCESSFULLY);
    ANJ_UNIT_ASSERT_EQUAL(anj_time_real_to_scalar(g_ntp_synchronized_time,
                                                  ANJ_TIME_UNIT_S),
                          expected_unix_time);

    // Second synchronization
    ANJ_UNIT_ASSERT_SUCCESS(anj_ntp_start(&ntp));

    // connection retry check
    ANJ_UNIT_ASSERT_EQUAL(mock.call_count[ANJ_NET_FUN_CONNECT], 1);
    mock.call_result[ANJ_NET_FUN_CONNECT] = ANJ_NET_EINPROGRESS;
    anj_ntp_step(&ntp);
    ANJ_UNIT_ASSERT_EQUAL(mock.call_count[ANJ_NET_FUN_CONNECT], 2);
    mock.call_result[ANJ_NET_FUN_CONNECT] = 0;
    anj_ntp_step(&ntp);
    ANJ_UNIT_ASSERT_EQUAL(mock.call_count[ANJ_NET_FUN_CONNECT], 3);

    anj_ntp_step(&ntp);
    uint32_t expected_unix_time_2 = 0x58657858;
    make_ntp_response(ntp_response, expected_unix_time_2);
    mock.bytes_to_recv = sizeof(ntp_response);
    mock.data_to_recv = ntp_response;
    anj_ntp_step(&ntp);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_callback_counter, 4);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_status, ANJ_NTP_STATUS_FINISHED_SUCCESSFULLY);
    ANJ_UNIT_ASSERT_EQUAL(anj_time_real_to_scalar(g_ntp_synchronized_time,
                                                  ANJ_TIME_UNIT_S),
                          expected_unix_time_2);
}

// termination during synchronization
// then next synchronization attempt
ANJ_UNIT_TEST(ntp, termination) {
    NTP_TEST_INIT();
    ANJ_UNIT_ASSERT_SUCCESS(anj_ntp_init(&anj, &ntp, &config));
    ANJ_UNIT_ASSERT_SUCCESS(anj_ntp_start(&ntp));
    SET_NET_MOCK_API();
    // connect
    anj_ntp_step(&ntp);
    // send request
    anj_ntp_step(&ntp);
    anj_ntp_terminate(&ntp);
    // disconnect
    anj_ntp_step(&ntp);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_status, ANJ_NTP_STATUS_FINISHED_WITH_ERROR);

    // next synchronization should succeed
    ANJ_UNIT_ASSERT_SUCCESS(anj_ntp_start(&ntp));
    anj_ntp_step(&ntp);
    anj_ntp_step(&ntp);
    anj_ntp_step(&ntp);
    anj_ntp_step(&ntp);
    ANJ_UNIT_ASSERT_EQUAL(anj_time_real_to_scalar(g_ntp_synchronized_time,
                                                  ANJ_TIME_UNIT_S),
                          expected_unix_time);
}

ANJ_UNIT_TEST(ntp, invalid_response) {
    NTP_TEST_INIT();
    ANJ_UNIT_ASSERT_SUCCESS(anj_ntp_init(&anj, &ntp, &config));
    ANJ_UNIT_ASSERT_SUCCESS(anj_ntp_start(&ntp));
    SET_NET_MOCK_API();
    // change the response size to be invalid
    mock.bytes_to_recv = sizeof(ntp_response) - 2;
    anj_ntp_step(&ntp);
    anj_ntp_step(&ntp);
    anj_ntp_step(&ntp);
    anj_ntp_step(&ntp);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_callback_counter, 2);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_status, ANJ_NTP_STATUS_FINISHED_WITH_ERROR);
}

// synchronization with two attempts: first fails because of timeout, second
// succeeds
ANJ_UNIT_TEST(ntp, two_attempts_timeout) {
    NTP_TEST_INIT();
    config.attempts = 2;
    ANJ_UNIT_ASSERT_SUCCESS(anj_ntp_init(&anj, &ntp, &config));
    SET_NET_MOCK_API();
    mock.bytes_to_recv = 0; // no response to simulate timeout

    ANJ_UNIT_ASSERT_SUCCESS(anj_ntp_start(&ntp));
    // connect
    anj_ntp_step(&ntp);
    // send request
    anj_ntp_step(&ntp);
    // try to receive response but timeout occurs
    anj_ntp_step(&ntp);
    mock_time_advance(anj_time_duration_new(6, ANJ_TIME_UNIT_S));
    anj_ntp_step(&ntp);
    ANJ_UNIT_ASSERT_EQUAL(mock.call_count[ANJ_NET_FUN_CONNECT], 1);
    ANJ_UNIT_ASSERT_EQUAL(mock.call_count[ANJ_NET_FUN_CLEANUP], 0);
    anj_ntp_step(&ntp);
    ANJ_UNIT_ASSERT_EQUAL(mock.call_count[ANJ_NET_FUN_CONNECT], 1);
    ANJ_UNIT_ASSERT_EQUAL(mock.call_count[ANJ_NET_FUN_CLEANUP], 1);
    anj_ntp_step(&ntp);
    ANJ_UNIT_ASSERT_EQUAL(mock.call_count[ANJ_NET_FUN_CONNECT], 2);
    // send request
    anj_ntp_step(&ntp);
    mock.bytes_to_recv = sizeof(ntp_response);
    // receive response
    anj_ntp_step(&ntp);
    // disconnect
    anj_ntp_step(&ntp);
    ANJ_UNIT_ASSERT_EQUAL(mock.call_count[ANJ_NET_FUN_CONNECT], 2);
    ANJ_UNIT_ASSERT_EQUAL(mock.call_count[ANJ_NET_FUN_CLEANUP], 2);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_callback_counter, 2);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_status, ANJ_NTP_STATUS_FINISHED_SUCCESSFULLY);
    ANJ_UNIT_ASSERT_EQUAL(anj_time_real_to_scalar(g_ntp_synchronized_time,
                                                  ANJ_TIME_UNIT_S),
                          expected_unix_time);
}

// synchronization with two attempts: first fails because of connection failure,
// second succeeds
ANJ_UNIT_TEST(ntp, two_attempts_connection_failure) {
    NTP_TEST_INIT();
    config.attempts = 2;
    ANJ_UNIT_ASSERT_SUCCESS(anj_ntp_init(&anj, &ntp, &config));
    SET_NET_MOCK_API();

    ANJ_UNIT_ASSERT_SUCCESS(anj_ntp_start(&ntp));
    // connect fails
    net_api_mock_force_connection_failure();
    anj_ntp_step(&ntp);
    ANJ_UNIT_ASSERT_EQUAL(mock.call_count[ANJ_NET_FUN_CONNECT], 0);
    ANJ_UNIT_ASSERT_EQUAL(mock.call_count[ANJ_NET_FUN_CLEANUP], 0);
    // retry connection
    anj_ntp_step(&ntp);
    // send request
    anj_ntp_step(&ntp);
    // receive response
    anj_ntp_step(&ntp);
    // disconnect
    anj_ntp_step(&ntp);
    ANJ_UNIT_ASSERT_EQUAL(mock.call_count[ANJ_NET_FUN_CONNECT], 1);
    ANJ_UNIT_ASSERT_EQUAL(mock.call_count[ANJ_NET_FUN_CLEANUP], 1);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_callback_counter, 2);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_status, ANJ_NTP_STATUS_FINISHED_SUCCESSFULLY);
    ANJ_UNIT_ASSERT_EQUAL(anj_time_real_to_scalar(g_ntp_synchronized_time,
                                                  ANJ_TIME_UNIT_S),
                          expected_unix_time);
}

// first synchronization fails twice, next succeeds
ANJ_UNIT_TEST(ntp, two_attempts_fail_next_succeeds) {
    NTP_TEST_INIT();
    config.attempts = 2;
    ANJ_UNIT_ASSERT_SUCCESS(anj_ntp_init(&anj, &ntp, &config));
    SET_NET_MOCK_API();
    ANJ_UNIT_ASSERT_SUCCESS(anj_ntp_start(&ntp));
    // connect fails
    net_api_mock_force_connection_failure();
    anj_ntp_step(&ntp);
    // disconnect step
    anj_ntp_step(&ntp);
    net_api_mock_force_connection_failure();
    anj_ntp_step(&ntp);
    // disconnect step
    anj_ntp_step(&ntp);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_callback_counter, 2);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_status, ANJ_NTP_STATUS_FINISHED_WITH_ERROR);

    // next synchronization should succeed
    ANJ_UNIT_ASSERT_SUCCESS(anj_ntp_start(&ntp));
    // connect, send, receive, disconnect
    anj_ntp_step(&ntp);
    anj_ntp_step(&ntp);
    anj_ntp_step(&ntp);
    anj_ntp_step(&ntp);

    ANJ_UNIT_ASSERT_EQUAL(g_ntp_callback_counter, 4);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_status, ANJ_NTP_STATUS_FINISHED_SUCCESSFULLY);
    ANJ_UNIT_ASSERT_EQUAL(anj_time_real_to_scalar(g_ntp_synchronized_time,
                                                  ANJ_TIME_UNIT_S),
                          expected_unix_time);
}

ANJ_UNIT_TEST(ntp, backup_server_usage) {
    NTP_TEST_INIT();
    char backup_addr[] = "backup.ntp.org";
    config.backup_ntp_server_address = backup_addr;
    ANJ_UNIT_ASSERT_SUCCESS(anj_ntp_init(&anj, &ntp, &config));
    SET_NET_MOCK_API();

    ANJ_UNIT_ASSERT_SUCCESS(anj_ntp_start(&ntp));
    // connect fails for primary server
    net_api_mock_force_connection_failure();
    anj_ntp_step(&ntp);
    // disconnect step
    anj_ntp_step(&ntp);
    // connect to backup server
    anj_ntp_step(&ntp);
    anj_ntp_step(&ntp);
    anj_ntp_step(&ntp);
    anj_ntp_step(&ntp);
    // check that backup server address was used
    ANJ_UNIT_ASSERT_EQUAL_STRING(mock.hostname, backup_addr);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_callback_counter, 2);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_status, ANJ_NTP_STATUS_FINISHED_SUCCESSFULLY);
    ANJ_UNIT_ASSERT_EQUAL(anj_time_real_to_scalar(g_ntp_synchronized_time,
                                                  ANJ_TIME_UNIT_S),
                          expected_unix_time);

    // check that next synchronization uses primary server again
    ANJ_UNIT_ASSERT_SUCCESS(anj_ntp_start(&ntp));
    anj_ntp_step(&ntp);
    ANJ_UNIT_ASSERT_EQUAL_STRING(mock.hostname, primary_addr);
}

// test periodic synchronization:
// - set period to 3 hours
// - advance time by 2 hours: no synchronization should occur
// - advance time by another 2 hours: synchronization should occur
// - verify that period is counted since last synchronization
// - proceed with another synchronization
ANJ_UNIT_TEST(ntp, period_synchronization) {
    NTP_TEST_INIT();
    config.ntp_period_hours = 3; // 3 hour
    ANJ_UNIT_ASSERT_SUCCESS(anj_ntp_init(&anj, &ntp, &config));
    SET_NET_MOCK_API();
    // nothing happens until period is exceeded
    anj_ntp_step(&ntp);
    anj_ntp_step(&ntp);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_status, ANJ_NTP_STATUS_INITIAL);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_callback_counter, 1);

    // advance time by 2 hours not exceeding period
    mock_time_advance(anj_time_duration_new(2, ANJ_TIME_UNIT_HOUR));
    anj_ntp_step(&ntp);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_status, ANJ_NTP_STATUS_INITIAL);

    // advance time by another 2 hours exceeding period
    mock_time_advance(anj_time_duration_new(2, ANJ_TIME_UNIT_HOUR));
    anj_ntp_step(&ntp);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_callback_counter, 3);
    // first ANJ_NTP_STATUS_PERIOD_EXCEEDED is set and then
    // ANJ_NTP_STATUS_IN_PROGRESS
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_status, ANJ_NTP_STATUS_IN_PROGRESS);

    anj_ntp_step(&ntp);
    anj_ntp_step(&ntp);
    anj_ntp_step(&ntp);
    anj_ntp_step(&ntp);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_callback_counter, 4);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_status, ANJ_NTP_STATUS_FINISHED_SUCCESSFULLY);
    ANJ_UNIT_ASSERT_EQUAL(anj_time_real_to_scalar(g_ntp_synchronized_time,
                                                  ANJ_TIME_UNIT_S),
                          expected_unix_time);

    // check that period is counted since last sync
    mock_time_advance(anj_time_duration_new(2, ANJ_TIME_UNIT_HOUR));
    anj_ntp_step(&ntp);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_callback_counter, 4);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_status, ANJ_NTP_STATUS_FINISHED_SUCCESSFULLY);
    mock_time_advance(anj_time_duration_new(2, ANJ_TIME_UNIT_HOUR));
    anj_ntp_step(&ntp);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_callback_counter, 6);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_status, ANJ_NTP_STATUS_IN_PROGRESS);
    mock.bytes_to_recv = sizeof(ntp_response);
    anj_ntp_step(&ntp);
    anj_ntp_step(&ntp);
    anj_ntp_step(&ntp);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_callback_counter, 7);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_status, ANJ_NTP_STATUS_FINISHED_SUCCESSFULLY);
    ANJ_UNIT_ASSERT_EQUAL(anj_time_real_to_scalar(g_ntp_synchronized_time,
                                                  ANJ_TIME_UNIT_S),
                          expected_unix_time);
}

// check two things:
// - changing NTP server address through DM API
// - whether changed address is used in next synchronization
ANJ_UNIT_TEST(ntp, ntp_address_changed) {
    NTP_TEST_INIT();
    ANJ_UNIT_ASSERT_SUCCESS(anj_ntp_init(&anj, &ntp, &config));
    anj_ntp_step(&ntp);

    // change NTP server address
    char new_addr[] = "new.ntp.pl";

    ANJ_UNIT_ASSERT_SUCCESS(
            _anj_dm_operation_begin(&anj,
                                    ANJ_OP_DM_WRITE_PARTIAL_UPDATE,
                                    false,
                                    &ANJ_MAKE_INSTANCE_PATH(3415, 0)));
    anj_io_out_entry_t record = {
        .type = ANJ_DATA_TYPE_STRING,
        .path = ANJ_MAKE_RESOURCE_PATH(3415, 0, 1),
        .value.bytes_or_string.data = (const uint8_t *) new_addr,
        .value.bytes_or_string.chunk_length = strlen(new_addr),
        .value.bytes_or_string.full_length_hint = strlen(new_addr),
    };
    ANJ_UNIT_ASSERT_SUCCESS(_anj_dm_write_entry(&anj, &record));
    ANJ_UNIT_ASSERT_SUCCESS(_anj_dm_operation_validate(&anj));
    _anj_dm_operation_end(&anj, ANJ_DM_TRANSACTION_SUCCESS);
    ANJ_UNIT_ASSERT_EQUAL_STRING(ntp.server_address, new_addr);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_callback_counter, 2);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_status, ANJ_NTP_STATUS_OBJECT_UPDATED);

    SET_NET_MOCK_API();
    ANJ_UNIT_ASSERT_SUCCESS(anj_ntp_start(&ntp));
    anj_ntp_step(&ntp);
    anj_ntp_step(&ntp);
    anj_ntp_step(&ntp);
    anj_ntp_step(&ntp);

    // check that new address was used
    ANJ_UNIT_ASSERT_EQUAL_STRING(mock.hostname, new_addr);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_callback_counter, 4);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_status, ANJ_NTP_STATUS_FINISHED_SUCCESSFULLY);
    ANJ_UNIT_ASSERT_EQUAL(anj_time_real_to_scalar(g_ntp_synchronized_time,
                                                  ANJ_TIME_UNIT_S),
                          expected_unix_time);
}

// check that if changing NTP server address to an invalid one through DM API
// is handled properly
ANJ_UNIT_TEST(ntp, ntp_address_change_failed) {
    NTP_TEST_INIT();
    ANJ_UNIT_ASSERT_SUCCESS(anj_ntp_init(&anj, &ntp, &config));
    anj_ntp_step(&ntp);

    // change NTP server address to an invalid one
    char new_addr[] = "invalidinvalidinvalidinvalidinvalid.ntp.pl";
    ANJ_UNIT_ASSERT_SUCCESS(
            _anj_dm_operation_begin(&anj,
                                    ANJ_OP_DM_WRITE_PARTIAL_UPDATE,
                                    false,
                                    &ANJ_MAKE_INSTANCE_PATH(3415, 0)));
    anj_io_out_entry_t record = {
        .type = ANJ_DATA_TYPE_STRING,
        .path = ANJ_MAKE_RESOURCE_PATH(3415, 0, 1),
        .value.bytes_or_string.data = (const uint8_t *) new_addr,
        .value.bytes_or_string.chunk_length = strlen(new_addr),
        .value.bytes_or_string.full_length_hint = strlen(new_addr),
    };
    ANJ_UNIT_ASSERT_EQUAL(_anj_dm_write_entry(&anj, &record),
                          ANJ_DM_ERR_INTERNAL);
    _anj_dm_operation_end(&anj, ANJ_DM_TRANSACTION_FAILURE);

    SET_NET_MOCK_API();
    ANJ_UNIT_ASSERT_SUCCESS(anj_ntp_start(&ntp));
    anj_ntp_step(&ntp);
    anj_ntp_step(&ntp);
    anj_ntp_step(&ntp);
    anj_ntp_step(&ntp);

    // check that previous address was used
    ANJ_UNIT_ASSERT_EQUAL_STRING(mock.hostname, primary_addr);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_callback_counter, 3);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_status, ANJ_NTP_STATUS_FINISHED_SUCCESSFULLY);
    ANJ_UNIT_ASSERT_EQUAL(anj_time_real_to_scalar(g_ntp_synchronized_time,
                                                  ANJ_TIME_UNIT_S),
                          expected_unix_time);
}

// check if changing NTP synchronization period through DM API works
ANJ_UNIT_TEST(ntp, ntp_period_changed) {
    NTP_TEST_INIT();
    config.ntp_period_hours = 3; // 3 hour

    ANJ_UNIT_ASSERT_SUCCESS(anj_ntp_init(&anj, &ntp, &config));
    anj_ntp_step(&ntp);

    // change NTP synchronization period
    ANJ_UNIT_ASSERT_SUCCESS(
            _anj_dm_operation_begin(&anj,
                                    ANJ_OP_DM_WRITE_PARTIAL_UPDATE,
                                    false,
                                    &ANJ_MAKE_INSTANCE_PATH(3415, 0)));
    anj_io_out_entry_t record = {
        .type = ANJ_DATA_TYPE_INT,
        .path = ANJ_MAKE_RESOURCE_PATH(3415, 0, 3),
        .value.int_value = 5,
    };
    ANJ_UNIT_ASSERT_SUCCESS(_anj_dm_write_entry(&anj, &record));
    ANJ_UNIT_ASSERT_SUCCESS(_anj_dm_operation_validate(&anj));
    _anj_dm_operation_end(&anj, ANJ_DM_TRANSACTION_SUCCESS);
    ANJ_UNIT_ASSERT_EQUAL(ntp.period_hours, 5);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_callback_counter, 2);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_status, ANJ_NTP_STATUS_OBJECT_UPDATED);

    SET_NET_MOCK_API();
    // advance time by 4 hours: no synchronization should occur
    mock_time_advance(anj_time_duration_new(4, ANJ_TIME_UNIT_HOUR));
    anj_ntp_step(&ntp);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_callback_counter, 2);
    // advance time by another 2 hours: synchronization should occur
    mock_time_advance(anj_time_duration_new(2, ANJ_TIME_UNIT_HOUR));
    anj_ntp_step(&ntp);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_callback_counter, 4);
    // first ANJ_NTP_STATUS_PERIOD_EXCEEDED is set and then
    // ANJ_NTP_STATUS_IN_PROGRESS
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_status, ANJ_NTP_STATUS_IN_PROGRESS);
    anj_ntp_step(&ntp);
    anj_ntp_step(&ntp);
    anj_ntp_step(&ntp);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_callback_counter, 5);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_status, ANJ_NTP_STATUS_FINISHED_SUCCESSFULLY);
    ANJ_UNIT_ASSERT_EQUAL(anj_time_real_to_scalar(g_ntp_synchronized_time,
                                                  ANJ_TIME_UNIT_S),
                          expected_unix_time);
}

#define READ_LAST_SYNC_RESOURCE()                                          \
    ANJ_UNIT_ASSERT_SUCCESS(                                               \
            _anj_dm_operation_begin(&anj,                                  \
                                    ANJ_OP_DM_READ,                        \
                                    false,                                 \
                                    &ANJ_MAKE_RESOURCE_PATH(3415, 0, 4))); \
    anj_io_out_entry_t record = { 0 };                                     \
    ANJ_UNIT_ASSERT_EQUAL(_anj_dm_get_read_entry(&anj, &record),           \
                          _ANJ_DM_LAST_RECORD);                            \
    _anj_dm_operation_end(&anj, ANJ_DM_TRANSACTION_SUCCESS)

#define READ_TIME_SYNC_ERR_RESOURCE()                                      \
    ANJ_UNIT_ASSERT_SUCCESS(                                               \
            _anj_dm_operation_begin(&anj,                                  \
                                    ANJ_OP_DM_READ,                        \
                                    false,                                 \
                                    &ANJ_MAKE_RESOURCE_PATH(3415, 0, 5))); \
    anj_io_out_entry_t record = { 0 };                                     \
    ANJ_UNIT_ASSERT_EQUAL(_anj_dm_get_read_entry(&anj, &record),           \
                          _ANJ_DM_LAST_RECORD);                            \
    _anj_dm_operation_end(&anj, ANJ_DM_TRANSACTION_SUCCESS)

// check if last synchronization time and time synchronization error resources
// are updated correctly
ANJ_UNIT_TEST(ntp, check_status_resources) {
    NTP_TEST_INIT();
    ANJ_UNIT_ASSERT_SUCCESS(anj_ntp_init(&anj, &ntp, &config));
    anj_ntp_step(&ntp);
    // advance time by 2 hours to have non-zero last sync time
    mock_time_advance(anj_time_duration_new(2, ANJ_TIME_UNIT_HOUR));

    SET_NET_MOCK_API();
    ANJ_UNIT_ASSERT_SUCCESS(anj_ntp_start(&ntp));
    anj_ntp_step(&ntp);
    anj_ntp_step(&ntp);
    anj_ntp_step(&ntp);
    anj_ntp_step(&ntp);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_callback_counter, 3);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_status, ANJ_NTP_STATUS_FINISHED_SUCCESSFULLY);

    {
        READ_LAST_SYNC_RESOURCE();
        ANJ_UNIT_ASSERT_EQUAL(record.value.int_value, 0);
    }
    // advance time by another 3 hours
    mock_time_advance(anj_time_duration_new(3, ANJ_TIME_UNIT_HOUR));
    {
        READ_LAST_SYNC_RESOURCE();
        ANJ_UNIT_ASSERT_EQUAL(record.value.int_value, 3);
    }
    // advance time by another 300 hours
    mock_time_advance(anj_time_duration_new(300, ANJ_TIME_UNIT_HOUR));
    {
        READ_LAST_SYNC_RESOURCE();
        ANJ_UNIT_ASSERT_EQUAL(record.value.int_value, 303);
    }
    { // check that time sync error resource is not set
        READ_TIME_SYNC_ERR_RESOURCE();
        ANJ_UNIT_ASSERT_EQUAL(record.value.bool_value, false);
    }

    // simulate synchronization error
    net_api_mock_force_connection_failure();
    ANJ_UNIT_ASSERT_SUCCESS(anj_ntp_start(&ntp));
    anj_ntp_step(&ntp);
    anj_ntp_step(&ntp);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_status, ANJ_NTP_STATUS_FINISHED_WITH_ERROR);
    { // check that time sync error resource is set
        READ_TIME_SYNC_ERR_RESOURCE();
        ANJ_UNIT_ASSERT_EQUAL(record.value.bool_value, true);
    }

    // last sync time should not be updated on error
    mock_time_advance(anj_time_duration_new(100, ANJ_TIME_UNIT_HOUR));
    {
        READ_LAST_SYNC_RESOURCE();
        ANJ_UNIT_ASSERT_EQUAL(record.value.int_value, 403);
    }
}

ANJ_UNIT_TEST(ntp, no_period_set) {
    NTP_TEST_INIT();
    config.ntp_period_hours = 0; // no periodic synchronization

    ANJ_UNIT_ASSERT_SUCCESS(anj_ntp_init(&anj, &ntp, &config));
    anj_ntp_step(&ntp);

    SET_NET_MOCK_API();
    // advance time by 10 hours: no synchronization should occur
    mock_time_advance(anj_time_duration_new(10, ANJ_TIME_UNIT_HOUR));
    anj_ntp_step(&ntp);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_status, ANJ_NTP_STATUS_INITIAL);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_callback_counter, 1);
}

// check if fractional part of NTP timestamp is handled correctly
ANJ_UNIT_TEST(ntp, fractional_part) {
    NTP_TEST_INIT();
    ANJ_UNIT_ASSERT_SUCCESS(anj_ntp_init(&anj, &ntp, &config));

    ANJ_UNIT_ASSERT_SUCCESS(anj_ntp_start(&ntp));
    SET_NET_MOCK_API();

    // ~0.5s in NTP fractional format
    uint32_t fraction = UINT32_MAX / 2 + 1;
    ntp_response[44] = (uint8_t) (fraction >> 24);
    ntp_response[45] = (uint8_t) (fraction >> 16);
    ntp_response[46] = (uint8_t) (fraction >> 8);
    ntp_response[47] = (uint8_t) (fraction);

    anj_ntp_step(&ntp);
    anj_ntp_step(&ntp);
    anj_ntp_step(&ntp);
    anj_ntp_step(&ntp);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_callback_counter, 2);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_status, ANJ_NTP_STATUS_FINISHED_SUCCESSFULLY);
    // check that fractional part was added correctly
    // convert expected value to milliseconds and add 500ms
    ANJ_UNIT_ASSERT_EQUAL(anj_time_real_to_scalar(g_ntp_synchronized_time,
                                                  ANJ_TIME_UNIT_MS),
                          (int64_t) expected_unix_time * 1000 + 500);
}

// check if fractional part of NTP timestamp is handled correctly for small
// fraction value
ANJ_UNIT_TEST(ntp, fractional_part_2) {
    NTP_TEST_INIT();
    ANJ_UNIT_ASSERT_SUCCESS(anj_ntp_init(&anj, &ntp, &config));

    ANJ_UNIT_ASSERT_SUCCESS(anj_ntp_start(&ntp));
    SET_NET_MOCK_API();

    // ~0.005s in NTP fractional format
    uint32_t fraction = UINT32_MAX / 200 + 1;
    ntp_response[44] = (uint8_t) (fraction >> 24);
    ntp_response[45] = (uint8_t) (fraction >> 16);
    ntp_response[46] = (uint8_t) (fraction >> 8);
    ntp_response[47] = (uint8_t) (fraction);

    anj_ntp_step(&ntp);
    anj_ntp_step(&ntp);
    anj_ntp_step(&ntp);
    anj_ntp_step(&ntp);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_callback_counter, 2);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_status, ANJ_NTP_STATUS_FINISHED_SUCCESSFULLY);
    // check that fractional part was added correctly
    // convert expected value to milliseconds and add 500ms
    ANJ_UNIT_ASSERT_EQUAL(anj_time_real_to_scalar(g_ntp_synchronized_time,
                                                  ANJ_TIME_UNIT_MS),
                          (int64_t) expected_unix_time * 1000 + 5);
}

// check if time after 2036 is handled correctly (NTP era rollover)
ANJ_UNIT_TEST(ntp, ntp_second_era) {
    NTP_TEST_INIT();
    ANJ_UNIT_ASSERT_SUCCESS(anj_ntp_init(&anj, &ntp, &config));

    ANJ_UNIT_ASSERT_SUCCESS(anj_ntp_start(&ntp));
    SET_NET_MOCK_API();

    // value must be lower than 2208988800 - parse_ntp_response() will add
    // 2^32 seconds to it to get time after 2036
    uint32_t second_era_time = 1208988800;
    ntp_response[40] = (uint8_t) (second_era_time >> 24);
    ntp_response[41] = (uint8_t) (second_era_time >> 16);
    ntp_response[42] = (uint8_t) (second_era_time >> 8);
    ntp_response[43] = (uint8_t) (second_era_time);

    anj_ntp_step(&ntp);
    anj_ntp_step(&ntp);
    anj_ntp_step(&ntp);
    anj_ntp_step(&ntp);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_callback_counter, 2);
    ANJ_UNIT_ASSERT_EQUAL(g_ntp_status, ANJ_NTP_STATUS_FINISHED_SUCCESSFULLY);
    // expected time is 2^32(NTP overflow) + second_era_time -
    // NTP_TIMESTAMP_DELTA
    int64_t expected_time =
            4294967296LL + (int64_t) second_era_time - 2208988800LL;
    ANJ_UNIT_ASSERT_EQUAL(anj_time_real_to_scalar(g_ntp_synchronized_time,
                                                  ANJ_TIME_UNIT_MS),
                          expected_time * 1000);
}

///////////////////////////////////////////////////////////////////////
////////////////////////// PERSISTENCE TESTS //////////////////////////
///////////////////////////////////////////////////////////////////////

static uint8_t g_membuf_data[256];
static size_t g_membuf_write_offset;
static size_t g_membuf_read_offset;
static bool g_membuf_read_error_enabled;
static int g_membuf_read_error_countdown;

static int mem_write_cb(void *ctx, const void *buf, size_t size) {
    (void) ctx;
    if (size == 0) {
        return 0;
    }
    if (g_membuf_write_offset + size > sizeof(g_membuf_data)) {
        return -1;
    }
    memcpy(g_membuf_data + g_membuf_write_offset, buf, size);
    g_membuf_write_offset += size;
    return 0;
}
static int mem_read_cb(void *ctx, void *buf, size_t size) {
    (void) ctx;
    if (size == 0) {
        return 0;
    }

    if (g_membuf_read_error_countdown) {
        g_membuf_read_error_countdown--;
    }
    if (g_membuf_read_error_enabled && g_membuf_read_error_countdown == 0) {
        return -1;
    }

    if (g_membuf_read_offset + size > g_membuf_write_offset) {
        return -1;
    }
    memcpy(buf, g_membuf_data + g_membuf_read_offset, size);
    g_membuf_read_offset += size;
    return 0;
}

#define INIT_ENV_PERSISTENCE()                       \
    anj_t anj = { 0 };                               \
    anj_ntp_t ntp;                                   \
    char primary_addr[] = "test.ntp.org";            \
    char secondary_addr[] = "backup.ntp.org";        \
    anj_ntp_configuration_t config = {               \
        .event_cb = ntp_event_callback,              \
        .ntp_server_address = primary_addr,          \
        .backup_ntp_server_address = secondary_addr, \
        .ntp_period_hours = 5,                       \
    };                                               \
    g_ntp_status = ANJ_NTP_STATUS_INITIAL;           \
    g_membuf_read_offset = 0;                        \
    g_membuf_write_offset = 0;                       \
    ANJ_UNIT_ASSERT_SUCCESS(anj_ntp_init(&anj, &ntp, &config));

// check resources one by one to avoid uninitialized memory
// comparision (bytes from padding)
static void compare_objects_after_persistence(anj_ntp_t *ntp1,
                                              anj_ntp_t *ntp2) {
    ANJ_UNIT_ASSERT_EQUAL(g_membuf_read_offset, g_membuf_write_offset);
    ANJ_UNIT_ASSERT_EQUAL_STRING(ntp1->server_address, ntp2->server_address);
    ANJ_UNIT_ASSERT_EQUAL_STRING(ntp1->backup_server_address,
                                 ntp2->backup_server_address);
    ANJ_UNIT_ASSERT_EQUAL(ntp1->period_hours, ntp2->period_hours);
}

static void persistence_store(anj_ntp_t *ntp) {
    anj_persistence_context_t ctx =
            anj_persistence_store_context_create(mem_write_cb, NULL);
    ANJ_UNIT_ASSERT_SUCCESS(anj_ntp_obj_store(ntp, &ctx));
}

static void persistence_restore(anj_ntp_t *ntp) {
    anj_persistence_context_t ctx =
            anj_persistence_restore_context_create(mem_read_cb, NULL);
    ANJ_UNIT_ASSERT_SUCCESS(anj_ntp_obj_restore(ntp, &ctx));
}

ANJ_UNIT_TEST(ntp, persistence_basic) {
    INIT_ENV_PERSISTENCE();

    // one address is longer than previous one another shorter
    anj_ntp_configuration_t config_2 = {
        .event_cb = ntp_event_callback,
        .ntp_server_address = "ddd",
        .backup_ntp_server_address = "eee.eee.eee.eee.eee",
        .ntp_period_hours = 10,
    };
    anj_t anj_2 = { 0 };
    anj_ntp_t ntp_2 = { 0 };
    ANJ_UNIT_ASSERT_SUCCESS(anj_ntp_init(&anj_2, &ntp_2, &config_2));

    // store ntp_2
    persistence_store(&ntp_2);
    // restore into ntp
    persistence_restore(&ntp);
    // compare ntp and ntp_2 - write resources must be equal after restore
    compare_objects_after_persistence(&ntp, &ntp_2);
}

ANJ_UNIT_TEST(ntp, persistence_empty_fields) {
    INIT_ENV_PERSISTENCE();
    // backup address is NULL, period is zero
    anj_ntp_configuration_t config_2 = {
        .event_cb = ntp_event_callback,
        .ntp_server_address = "ddd",
        .backup_ntp_server_address = NULL,
    };
    anj_t anj_2 = { 0 };
    anj_ntp_t ntp_2 = { 0 };
    ANJ_UNIT_ASSERT_SUCCESS(anj_ntp_init(&anj_2, &ntp_2, &config_2));
    ANJ_UNIT_ASSERT_EQUAL_STRING(ntp_2.backup_server_address, "");
    ANJ_UNIT_ASSERT_EQUAL(ntp_2.period_hours, 0);

    // store ntp_2
    persistence_store(&ntp_2);
    // restore into ntp
    persistence_restore(&ntp);
    // compare ntp and ntp_2 - write resources must be equal after restore
    compare_objects_after_persistence(&ntp, &ntp_2);
}

ANJ_UNIT_TEST(ntp, persistence_wrong_magic) {
    INIT_ENV_PERSISTENCE();

    // store ntp
    persistence_store(&ntp);
    // corrupt magic number
    g_membuf_data[0] = 0xFF;
    // restore into ntp_2
    anj_ntp_t ntp_2 = { 0 };
    anj_persistence_context_t ctx =
            anj_persistence_restore_context_create(mem_read_cb, NULL);
    ANJ_UNIT_ASSERT_EQUAL(anj_ntp_obj_restore(&ntp_2, &ctx), -1);
}
